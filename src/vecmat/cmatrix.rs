//! Implements basic matrix type and utilities.
use std::iter::successors;
use std::ops::{Add, Mul, Neg};

use num::{One, Zero};

use crate::collect_array::CollectArray;
use crate::vecmat::CVector;

/// Matrix whose size whose known at compile time.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CMatrix<T, const ROWS: usize, const COLS: usize>(pub(crate) [[T; COLS]; ROWS]);

impl<T, const ROWS: usize, const COLS: usize> CMatrix<T, ROWS, COLS> {
    pub fn new(elements: [[T; COLS]; ROWS]) -> Self {
        CMatrix(elements)
    }
}

impl<T> CMatrix<T, 2, 2>
where
    T: Copy + Zero + One + Neg<Output = T>,
{
    /// An identity transformation matrix.
    #[inline]
    pub fn identity_mat() -> Self {
        CMatrix([[T::one(), T::zero()], [T::zero(), T::one()]])
    }

    /// A transformation matrix that will rotate the given vector a fourth of its way around the origin.
    /// Such rotation describes the rotational symmetry of a square centered at the origin.
    #[inline]
    pub fn rotate_mat() -> Self {
        CMatrix([[T::zero(), -T::one()], [T::one(), T::zero()]])
    }

    /// A suite of rotational matrices generated by [`CMatrix::rotate_mat`].
    pub fn rotate_suite() -> [Self; 4] {
        successors(Some(Self::identity_mat()), |&m| {
            Some(CMatrix::rotate_mat() * m)
        })
        .collect_trunc()
        .unwrap()
    }
}

impl<T> CMatrix<T, 3, 3>
where
    T: Copy + Zero + One + Neg<Output = T>,
{
    /// An identity transformation matrix.
    #[inline]
    pub fn identity_mat() -> Self {
        CMatrix([
            [T::one(), T::zero(), T::zero()],
            [T::zero(), T::one(), T::zero()],
            [T::zero(), T::zero(), T::one()],
        ])
    }

    /// A transformation matrix that will rotate the given vector a third of its way
    /// around the line described by the equation `x = y = z`.
    /// Such rotation swaps x-face to y-face, y-face to z-face, and z-face to x-face
    /// of an axis-aligned imaginary cube centered at the origin.
    #[inline]
    pub fn xyz_rotate_mat() -> Self {
        CMatrix([
            [T::zero(), T::one(), T::zero()],
            [T::zero(), T::zero(), T::one()],
            [T::one(), T::zero(), T::zero()],
        ])
    }

    /// A transformation matrix that will rotate the given vector half of its way
    /// around the line described by the equation `x = y`.
    /// Such rotation swaps x-face with y-face, and z-face with its opposite side.
    #[inline]
    pub fn xy_rotate_mat() -> Self {
        CMatrix([
            [T::zero(), T::one(), T::zero()],
            [T::one(), T::zero(), T::zero()],
            [T::zero(), T::zero(), -T::one()],
        ])
    }

    /// A transformation matrix that will rotate the given vector a fourth of its ways around the z-axis.
    /// Such rotation describes the rotational symmetry of a xy-square centered at the origin.
    #[inline]
    pub fn z_rotate_mat() -> Self {
        CMatrix([
            [T::zero(), -T::one(), T::zero()],
            [T::one(), T::zero(), T::zero()],
            [T::zero(), T::zero(), T::one()],
        ])
    }

    /// A suite of rotational matrices generated by [`CMatrix::xyz_rotate_mat`].
    pub fn xyz_rotate_suite() -> [Self; 3] {
        successors(Some(Self::identity_mat()), |&m| {
            Some(CMatrix::xyz_rotate_mat() * m)
        })
        .collect_trunc()
        .unwrap()
    }

    /// A suite of rotational matrices generated by [`CMatrix::xy_rotate_mat`].
    pub fn xy_rotate_suite() -> [Self; 2] {
        successors(Some(Self::identity_mat()), |&m| {
            Some(CMatrix::xy_rotate_mat() * m)
        })
        .collect_trunc()
        .unwrap()
    }

    /// A suite of rotational matrices generated by [`CMatrix::xy_rotate_mat`].
    pub fn z_rotate_suite() -> [Self; 4] {
        successors(Some(Self::identity_mat()), |&m| {
            Some(CMatrix::z_rotate_mat() * m)
        })
        .collect_trunc()
        .unwrap()
    }
}

impl<T, const ISIZE: usize, const JSIZE: usize> Mul<CVector<T, JSIZE>> for CMatrix<T, ISIZE, JSIZE>
where
    T: Copy + Add<Output = T> + Zero + Mul<Output = T>,
{
    type Output = CVector<T, ISIZE>;

    fn mul(self, rhs: CVector<T, JSIZE>) -> Self::Output {
        let result: [_; ISIZE] = (0..ISIZE)
            .map(|i| {
                (0..JSIZE)
                    .map(|j| self.0[i][j] * rhs.0[j])
                    .fold(T::zero(), |acc, x| acc + x)
            })
            .collect_exact()
            .unwrap();
        CVector(result)
    }
}

impl<T, const ISIZE: usize, const JSIZE: usize, const KSIZE: usize> Mul<CMatrix<T, JSIZE, KSIZE>>
    for CMatrix<T, ISIZE, JSIZE>
where
    T: Copy + Add<Output = T> + Zero + Mul<Output = T>,
{
    type Output = CMatrix<T, ISIZE, KSIZE>;

    fn mul(self, rhs: CMatrix<T, JSIZE, KSIZE>) -> Self::Output {
        let result: [[_; KSIZE]; ISIZE] = (0..ISIZE)
            .map(|i| {
                (0..KSIZE)
                    .map(|k| {
                        (0..JSIZE)
                            .map(|j| self.0[i][j] * rhs.0[j][k])
                            .fold(T::zero(), |acc, x| acc + x)
                    })
                    .collect_exact()
                    .unwrap()
            })
            .collect_exact()
            .unwrap();
        CMatrix(result)
    }
}
