//! Implements basic matrix type and utilities.
use std::iter::successors;
use std::ops::{Add, Mul, Neg};

use num::{One, Zero};

use crate::collect_array::CollectArray;
use crate::vecmat::CardinalVector;

/// Matrix whose size whose known at compile time.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct CardinalMatrix<T, const ROWS: usize, const COLS: usize>(pub(crate) [[T; COLS]; ROWS]);

impl<T, const ROWS: usize, const COLS: usize> CardinalMatrix<T, ROWS, COLS> {
    pub fn new(elements: [[T; COLS]; ROWS]) -> Self {
        CardinalMatrix(elements)
    }
}

impl<T> CardinalMatrix<T, 2, 2>
where
    T: Copy + Zero + One + Neg<Output = T>,
{
    /// An identity transformation matrix.
    #[inline]
    pub fn identity_mat() -> Self {
        CardinalMatrix([[T::one(), T::zero()], [T::zero(), T::one()]])
    }

    /// A transformation matrix that will rotate the given vector a fourth of its way around the origin.
    /// Such rotation describes the rotational symmetry of a square centered at the origin.
    #[inline]
    pub fn rotate_mat() -> Self {
        CardinalMatrix([[T::zero(), -T::one()], [T::one(), T::zero()]])
    }

    /// A suite of rotational matrices generated by [`CardinalMatrix::rotate_mat`].
    pub fn rotate_suite() -> [Self; 4] {
        successors(Some(Self::identity_mat()), |&m| {
            Some(CardinalMatrix::rotate_mat() * m)
        })
        .collect_trunc()
        .unwrap()
    }
}

impl<T> CardinalMatrix<T, 3, 3>
where
    T: Copy + Zero + One + Neg<Output = T>,
{
    /// An identity transformation matrix.
    #[inline]
    pub fn identity_mat() -> Self {
        CardinalMatrix([
            [T::one(), T::zero(), T::zero()],
            [T::zero(), T::one(), T::zero()],
            [T::zero(), T::zero(), T::one()],
        ])
    }

    /// A transformation matrix that will rotate the given vector a third of its way
    /// around the line described by the equation `x = y = z`.
    /// Such rotation swaps x-face to y-face, y-face to z-face, and z-face to x-face
    /// of an axis-aligned imaginary cube centered at the origin.
    #[inline]
    pub fn xyz_rotate_mat() -> Self {
        CardinalMatrix([
            [T::zero(), T::one(), T::zero()],
            [T::zero(), T::zero(), T::one()],
            [T::one(), T::zero(), T::zero()],
        ])
    }

    /// A transformation matrix that will rotate the given vector half of its way
    /// around the line described by the equation `x = y`.
    /// Such rotation swaps x-face with y-face, and z-face with its opposite side.
    #[inline]
    pub fn xy_rotate_mat() -> Self {
        CardinalMatrix([
            [T::zero(), T::one(), T::zero()],
            [T::one(), T::zero(), T::zero()],
            [T::zero(), T::zero(), -T::one()],
        ])
    }

    /// A transformation matrix that will rotate the given vector a fourth of its ways around the z-axis.
    /// Such rotation describes the rotational symmetry of a xy-square centered at the origin.
    #[inline]
    pub fn z_rotate_mat() -> Self {
        CardinalMatrix([
            [T::zero(), -T::one(), T::zero()],
            [T::one(), T::zero(), T::zero()],
            [T::zero(), T::zero(), T::one()],
        ])
    }

    /// A suite of rotational matrices generated by [`CardinalMatrix::xyz_rotate_mat`].
    pub fn xyz_rotate_suite() -> [Self; 3] {
        successors(Some(Self::identity_mat()), |&m| {
            Some(CardinalMatrix::xyz_rotate_mat() * m)
        })
        .collect_trunc()
        .unwrap()
    }

    /// A suite of rotational matrices generated by [`CardinalMatrix::xy_rotate_mat`].
    pub fn xy_rotate_suite() -> [Self; 2] {
        successors(Some(Self::identity_mat()), |&m| {
            Some(CardinalMatrix::xy_rotate_mat() * m)
        })
        .collect_trunc()
        .unwrap()
    }

    /// A suite of rotational matrices generated by [`CardinalMatrix::xy_rotate_mat`].
    pub fn z_rotate_suite() -> [Self; 4] {
        successors(Some(Self::identity_mat()), |&m| {
            Some(CardinalMatrix::z_rotate_mat() * m)
        })
        .collect_trunc()
        .unwrap()
    }
}

impl<T, const ISIZE: usize, const JSIZE: usize> Mul<CardinalVector<T, JSIZE>>
    for CardinalMatrix<T, ISIZE, JSIZE>
where
    T: Copy + Add<Output = T> + Zero + Mul<Output = T>,
{
    type Output = CardinalVector<T, ISIZE>;

    fn mul(self, rhs: CardinalVector<T, JSIZE>) -> Self::Output {
        let result: [_; ISIZE] = (0..ISIZE)
            .map(|i| {
                (0..JSIZE)
                    .map(|j| self.0[i][j] * rhs.0[j])
                    .fold(T::zero(), |acc, x| acc + x)
            })
            .collect_exact()
            .unwrap();
        CardinalVector(result)
    }
}

impl<T, const ISIZE: usize, const JSIZE: usize, const KSIZE: usize>
    Mul<CardinalMatrix<T, JSIZE, KSIZE>> for CardinalMatrix<T, ISIZE, JSIZE>
where
    T: Copy + Add<Output = T> + Zero + Mul<Output = T>,
{
    type Output = CardinalMatrix<T, ISIZE, KSIZE>;

    fn mul(self, rhs: CardinalMatrix<T, JSIZE, KSIZE>) -> Self::Output {
        let result: [[_; KSIZE]; ISIZE] = (0..ISIZE)
            .map(|i| {
                (0..KSIZE)
                    .map(|k| {
                        (0..JSIZE)
                            .map(|j| self.0[i][j] * rhs.0[j][k])
                            .fold(T::zero(), |acc, x| acc + x)
                    })
                    .collect_exact()
                    .unwrap()
            })
            .collect_exact()
            .unwrap();
        CardinalMatrix(result)
    }
}
